\documentclass[12pt,a4paper]{article}

% Compile with: XeLaTeX because it supports French + Arabic Unicode

\usepackage{fontspec}
\usepackage{polyglossia}
\setmainlanguage{french}
\setotherlanguage{arabic}

% Choose fonts (change Arabic font if you prefer another one installed on Windows)
\setmainfont{Latin Modern Roman}
\newfontfamily\arabicfont[Script=Arabic]{Traditional Arabic}

\usepackage[margin=2.2cm]{geometry}
\usepackage{setspace}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{titlesec}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{fancyhdr}


\geometry{margin=2.5cm}
\setstretch{1.2}

\titleformat{\section}{\bfseries\Large}{\thesection.}{0.3em}{}
\titleformat{\subsection}{\bfseries\large}{\thesubsection.}{0.3em}{}

\pagestyle{fancy}
\fancyhf{}
% \fancyhead[L]{\small Rapport Technique -- Moteur Morphologique Arabe}
\fancyhead[R]{\small \thepage}
\renewcommand{\headrulewidth}{0.2pt}

\titleformat{\section}{\large\bfseries}{\thesection.}{0.5em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection.}{0.5em}{}
\setlength{\parskip}{0.4em}
\setlength{\parindent}{0em}

\begin{document}

\begin{center}
    {\LARGE \textbf{Rapport Technique}}\\[0.3cm]
    {\Large Moteur de Génération et de Validation\\Morphologique de la Langue Arabe}\\[0.5cm]
    {\normalsize Réalisé par Eya Gharbi et Zaghouani Ayoub}\\
    {\normalsize Classe 1ING4}
\end{center}


\section{Présentation générale}
Ce projet implémente un moteur de dérivation morphologique arabe capable de générer des formes dérivées à partir d’un radical trilitère et d’un schème, et de valider si un mot dérivé appartient à un radical donné.
\section{Chargement des données}
Au démarrage, le système charge deux fichiers texte :
\begin{itemize}
    \item \textbf{roots.txt} : liste initiale des racines.
    \item \textbf{patterns.txt} : liste initiale des schèmes.
\end{itemize}
Ces fichiers jouent le rôle d’une petite base de données locale permettant de peupler les structures en mémoire avant tout traitement.

\section{Structures de données utilisées}

\subsection{Arbre binaire de recherche}

Les racines trilittérales (ex : \textarabic{ك-ت-ب}) sont stockées sous forme compacte (\textarabic{كتب}).

Chaque lettre arabe est représentée par son code Unicode. La comparaison lexicographique repose donc sur l’ordre Unicode des caractères, ce qui permet un tri naturel sans transformation supplémentaire.

Chaque nœud contient :
\begin{itemize}
\item La racine compacte,
\item Une liste chaînée des mots dérivés,
\item Un pointeur vers le sous-arbre gauche,
\item Un pointeur vers le sous-arbre droit.
\end{itemize}

\textbf{Normalisation en entrée:} Toute racine est d’abord normalisée : suppression des diacritiques, unification des formes d’alef, vérification du format \textarabic{ك-ت-ب}.

\textbf{Encodage et ordre:} Chaque racine est encodée en forme compacte (ex : \textarabic{كتب}). Chaque lettre arabe est ramenée à un code ordonné (ordre Unicode/arabique), puis la clé compacte est comparée lexicographiquement pour positionner le nœud dans l’arbre.

\textbf{Insertion :}Descente récursive selon l’ordre lexicographique. Doublons refusés.

\textbf{Suppression:} La suppression suit les trois cas classiques : feuille, un enfant, deux enfants avec remplacement par le successeur.

\paragraph{Complexité:}
\begin{center}
\begin{tabular}{lcc}
\toprule
\textbf{Opération} & \textbf{Cas moyen} & \textbf{Pire cas} \\
\midrule
Insertion         & $O(\log n)$ & $O(n)$ \\
Recherche         & $O(\log n)$ & $O(n)$ \\
Suppression       & $O(\log n)$ & $O(n)$ \\
Parcours in-order & $O(n)$      & $O(n)$ \\
Hauteur           & $O(n)$      & $O(n)$ \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Liste chaînée}
Chaque nœud de racine contient une \textbf{liste chaînée} de dérivés validés (mot + fréquence).  
Cette structure permet de :
\begin{itemize}
    \item éviter les recalculs et alléger la mémoire.
    \item insérer simplement des mots dérivés.
    \item conserver un historique morphologique.
\end{itemize}


\subsection{Table de hachage}
Les schèmes sont stockés dans une \textbf{table de hachage à chaînage}. Chaque cellule pointe vers une liste chaînée de n\oe uds portant le schème normalisé et sa règle de dérivation.

\textbf{Fonction de hachage:} Utilise une fonction polynomiale \texttt{\_hash(key)} de type :
\[
h(k) = \left(\sum_{i=0}^{\lvert k\rvert-1} \operatorname{ord}(k_i) \cdot 131^{i}\right) \bmod 37
\]
\textbf{Note:} La taille est fixée à \textbf{$m$ = 37}, choisie comme nombre premier pour réduire les collisions.

\textbf{Type d’entrée.} Les schèmes sont validés :
\begin{itemize}
    \item présence des lettres \textarabic{ف ع ل},
    \item lettres arabes uniquement,
    \item conservation de la shadda (si présente).
\end{itemize}

\textbf{Normalisation:} Chaque schème est normalisé (diacritiques supprimés sauf shadda, variantes d’alef unifiées).  
Les schèmes doivent contenir \textarabic{ف ع ل} et respecter une longueur minimale.

\textbf{Règle de dérivation:} Elle est identique au schème normalisé : la dérivation consiste uniquement à substituer \textarabic{ف ع ل} par les lettres du radical =>  Approche \texttt{rule = pattern}

\textbf{Chaînage:} Chaque case de la table pointe vers une \textbf{liste chaînée} de schèmes.  
Si deux schèmes ont le même hash, ils sont ajoutés à la liste du même bucket.  
La recherche parcourt cette liste jusqu’à trouver la clé exacte.

\paragraph{Complexité:}
\begin{center}
\begin{tabular}{lcc}
\toprule
\textbf{Opération} & \textbf{Cas moyen} & \textbf{Pire cas} \\
\midrule
Insertion   & $O(1)$     & $O(p)$ \\
Recherche   & $O(1)$     & $O(p)$ \\
Suppression & $O(1)$     & $O(p)$ \\
Itération   & $O(m + p)$ & $O(m + p)$ \\
\bottomrule
\end{tabular}
\end{center}
où $p$ est le nombre de schèmes et $m$ la capacité de la table. 

\section{Algorithmes de génération et validation morphologique}

\subsection{Génération}
\begin{enumerate}
    \item Normaliser le radical.
    \item Vérifier l’existence du schème dans la table.
    \item Substituer \textarabic{ف ع ل} par les lettres du radical.
    \item Retourner le mot dérivé et le stocker dans la liste chaînée.
\end{enumerate}

L'algorithme de génération (\texttt{MorphologicalGenerator}) prend en entrée une racine et un schème, puis produit un mot dérivé. Le processus se décompose en~:

\begin{enumerate}[nosep]
    \item \textbf{Normalisation de la racine donnée}~: suppression des diacritiques, unification des formes d’alef, vérification du format trilitère. Coût : $O(k)$ où $k$ est la longueur de la racine (typiquement 3 lettres).
    \item \textbf{Validation de la racine}~: recherche dans le BST -- $O(\log n)$ en moyenne.
    \item \textbf{Validation du schème}~: recherche dans la table de hachage -- $O(1)$ amorti.
    \item \textbf{Dérivation}~: la règle associée au schème est extraite. Les lettres-repères (\textarabic{ف}, \textarabic{ع}, \textarabic{ل}) sont remplacées par les 3 lettres de la racine. Le parcours du schème est en $O(\lvert s\rvert)$ où $\lvert s\rvert$ est la longueur du schème (typiquement 4--7 caractères).
    \item \textbf{Stockage}~: le mot dérivé est ajouté à la \texttt{DerivedWordList} du n\oe ud racine.
\end{enumerate}

\paragraph{Complexité totale d'une génération unitaire~:}
\[
T_{\text{gen}}(n, p) = O(\log n) + O(1) + O(\lvert s\rvert) = O(\log n)
\]
La génération d'une famille complète (tous les schèmes pour une racine, \texttt{generate\_family}) itère sur les $p$ schèmes~:
\[
T_{\text{family}}(n, p) = O(\log n) + O\!\left(\sum_{i=1}^{p}(1 + \lvert s_i\rvert)\right) = O(\log n + p \cdot \bar{s})
\]
où $\bar{s}$ est la longueur moyenne d'un schème.

\subsection{Validation}
\begin{enumerate}
    \item Vérifier l’existence du radical.
    \item Générer les mots pour chaque schème.
    \item Comparer au mot donné (normalisé).
    \item Valider et stocker si correspondance.
\end{enumerate}

L'algorithme de validation (\texttt{MorphologicalValidator}) détermine si un mot donné peut être dérivé d'une racine. La stratégie adoptée est une \textbf{validation par ré-génération exhaustive}~:

\begin{enumerate}[nosep]
    \item \textbf{Recherche de la racine} dans le BST -- $O(\log n)$.
    \item \textbf{Itération} sur tous les schèmes de la table de hachage.
    \item Pour chaque schème, \textbf{génération} du mot dérivé correspondant via le générateur.
    \item \textbf{Comparaison} du mot généré (normalisé) avec le mot saisi (normalisé).
    \item Si une correspondance est trouvée~: résultat \texttt{OUI} + schème identifié. Sinon~: \texttt{NON}.
\end{enumerate}

\paragraph{Complexité totale d'une validation~:}
\[
T_{\text{val}}(n, p) = O(\log n) + O(p \cdot \bar{s}) = O(\log n + p)
\]

\section{Choix et justification des algorithmes}
\textbf{ABR pour racines:} L’objectif était d’obtenir une recherche en moyenne rapide avec un coût mémoire faible. Un ABR permet un accès \textbf{logarithmique en moyenne} si l’arbre est équilibré. Dans ce projet, aucun AVL/Red-Black n’est imposé, donc le pire cas reste $O(n)$. Cette différence est explicitée dans la section complexité et respecte la contrainte théorique du projet en moyenne, même si le pire cas n’est pas logarithmique.

\textbf{Justification mathématique du $O(\log n)$ moyen:}  
Dans un ABR issu d’une insertion d’éléments en ordre aléatoire, la hauteur moyenne est proportionnelle à $\log n$. Plus précisément, l’espérance de la hauteur est $O(\log n)$ et la profondeur moyenne d’un nœud est $O(\log n)$. Ainsi, les opérations de recherche et d’insertion ont un coût moyen $O(\log n)$, même si le pire cas dégénéré reste $O(n)$.

\textbf{Table de hachage pour schèmes:} Le nombre de schèmes est fixe et relativement petit : un accès en $O(1)$ moyen est optimal. Le chaînage a été choisi pour éviter la réallocation et simplifier les suppressions.

\textbf{Validation exhaustive:} La validation par génération sur l’ensemble des schèmes garantit la cohérence linguistique, sans heuristique ni approximation.

\textbf{Normalisation:
} Une normalisation stricte évite des collisions sémantiques (ex. variantes d’alef, diacritiques), ce qui stabilise le comportement des algorithmes.

\section{Complexité algorithmique}
Soient $n$ le nombre de racines, $P$ le nombre de schèmes, $k$ la longueur du schème.

\begin{tabular}{|l|c|c|}
\hline
\textbf{Opération} & \textbf{Meilleur cas} & \textbf{Pire cas} \\
\hline
Recherche ABR & $O(1)$ & $O(n)$ \\
Insertion ABR & $O(1)$ & $O(n)$ \\
Suppression ABR & $O(1)$ & $O(n)$ \\
Recherche/insertion Hash & $O(1)$ & $O(P)$ \\
Génération & $O(k)$ & $O(k)$ \\
Validation & $O(k)$ & $O(P \times k)$ \\
\hline
\end{tabular}

\textbf{Approche d’optimisation.} Les structures choisies minimisent la complexité moyenne : ABR pour l’ordre, table de hachage pour l’accès, et stockage des dérivés pour éviter des recalculs.

\begin{center}
\begin{tabular}{l c c}
\toprule
\textbf{Opération} & \textbf{Cas moyen} & \textbf{Pire cas} \\
\midrule
Insertion d'une racine         & $O(\log n)$     & $O(n)$ \\
Recherche d'une racine         & $O(\log n)$     & $O(n)$ \\
Suppression d'une racine       & $O(\log n)$     & $O(n)$ \\
Insertion d'un schème          & $O(1)$          & $O(p)$ \\
Recherche d'un schème          & $O(1)$          & $O(p)$ \\
Génération unitaire            & $O(\log n)$     & $O(n)$ \\
Génération familiale           & $O(\log n + p)$ & $O(n + p)$ \\
Validation d'un mot            & $O(\log n + p)$ & $O(n + p)$ \\
Chargement racines fichier     & $O(n \log n)$   & $O(n^2)$ \\
Chargement schèmes fichier     & $O(p)$          & $O(p^2/m)$ \\
\bottomrule
\end{tabular}
\end{center}

\section{Difficultés rencontrées}
\begin{itemize}
    \item Normalisation cohérente entre racines et schèmes.
    \item Gestion des collisions dans la table de hachage.
    \item Contrôle des duplicatas dans ABR et hash.
    \item Équilibrage implicite du ABR sans auto-balancement.
\end{itemize}

\section{Point d’originalité}
Le système est exploité comme un \textbf{dictionnaire morphologique} : chaque schème est associé à une définition, et chaque dérivé validé peut être affiché avec son sens linguistique. Cette exploitation donne une valeur appliquée aux structures de données.
Cette exploitation démontre l’application concrète des structures algorithmiques développées.

\section{Conclusion}
Le moteur morphologique proposé combine trois structures de données classiques de manière cohérente. L'analyse de complexité montre que le système est efficace pour un usage pratique~: $O(\log n)$ pour les opérations courantes sur les racines et $O(1)$ amorti pour les schèmes.
\end{document}

