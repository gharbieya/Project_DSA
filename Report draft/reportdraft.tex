\documentclass[11pt,a4paper]{article}

% Compile with XeLaTeX

\usepackage{fontspec}
\usepackage{polyglossia}
\setmainlanguage{french}
\setotherlanguage{arabic}

\setmainfont{Latin Modern Roman}
\newfontfamily\arabicfont[Script=Arabic]{Traditional Arabic}

\usepackage[margin=2.3cm]{geometry}
\usepackage{setspace}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{enumitem}
\usepackage{titlesec}
\usepackage{fancyhdr}

\setstretch{1.1}
\setlength{\parindent}{0pt}
\setlength{\parskip}{0.4em}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[R]{\thepage}
\renewcommand{\headrulewidth}{0.2pt}

\titleformat{\section}{\large\bfseries}{\thesection.}{0.5em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection.}{0.5em}{}

\begin{document}

\begin{center}
{\Large \textbf{Rapport Technique}}\\[0.2cm]
{\normalsize Moteur de Génération et Validation Morphologique Arabe}\\[0.3cm]
{\small Eya Gharbi -- Zaghouani Ayoub}\\
{\small Classe 1ING4}
\end{center}

\section{Présentation générale}

Ce projet implémente un moteur de dérivation morphologique arabe capable de générer des formes dérivées à partir d’un radical trilitère et d’un schème, et de valider si un mot dérivé appartient à un radical donné. L’objectif principal est d’optimiser les performances en choisissant des structures de données adaptées afin de minimiser la complexité algorithmique moyenne.

\section{Chargement des données}

Au démarrage :
\begin{itemize}[nosep]
\item \texttt{roots.txt} charge les racines dans un ABR.
\item \texttt{patterns.txt} charge les schèmes dans une table de hachage.
\end{itemize}

\section{Structures de données}

\subsection{Arbre Binaire de Recherche (ABR)}

Les racines trilittérales (ex : \textarabic{ك-ت-ب}) sont stockées sous forme compacte (\textarabic{كتب}).  
La comparaison repose sur l’ordre Unicode.

Chaque nœud contient :
\begin{itemize}[nosep]
\item la racine compacte,
\item une liste chaînée de dérivés,
\item deux pointeurs (gauche/droite).
\end{itemize}

\textbf{Normalisation :} suppression des diacritiques, unification des variantes d’alef et vérification stricte du format.

\textbf{Insertion :} descente récursive selon l’ordre lexicographique. Les doublons sont refusés.

\textbf{Suppression :} trois cas classiques (feuille, un enfant, deux enfants avec remplacement par le successeur).

Une structure linéaire aurait impliqué une recherche en $O(n)$.  
L’ABR permet une recherche en $O(\log n)$ en moyenne, réduisant significativement le coût des accès fréquents aux racines.

\subsection{Liste chaînée}

Chaque racine possède une liste de mots dérivés (mot + fréquence).  
Cette structure permet un stockage léger et évite les recalculs lors des validations répétées.

\subsection{Table de hachage}

Les schèmes sont stockés dans une table de hachage de taille fixe $m=37$ (nombre premier).

Fonction de hachage polynomiale :

\[
h(k)=\left(\sum_{i=0}^{|k|-1} \operatorname{ord}(k_i)\cdot131^i\right)\bmod 37
\]

\textbf{Validation des schèmes :}
\begin{itemize}[nosep]
\item présence des lettres \textarabic{ف ع ل},
\item lettres arabes uniquement,
\item conservation éventuelle de la shadda.
\end{itemize}

\textbf{Normalisation :} suppression des diacritiques (sauf shadda) et unification des variantes Unicode.

\textbf{Règle de dérivation :} identique au schème normalisé (\texttt{rule = pattern}).  
La dérivation consiste à substituer \textarabic{ف ع ل} par les lettres de la racine.

\textbf{Chaînage :} chaque bucket contient une liste chaînée.  
En cas de collision, les schèmes sont ajoutés à la liste correspondante.

Le pire cas correspond à une collision totale où tous les schèmes sont placés dans un seul bucket. En pratique, la fonction polynomiale et le choix d’un nombre premier rendent ce cas hautement improbable.

\section{Algorithmes}

\subsection{Génération}

\begin{enumerate}[nosep]
\item Normalisation de la racine
\item Recherche dans l’ABR
\item Recherche du schème dans la table de hachage
\item Application de la règle
\item Stockage dans la liste chaînée
\end{enumerate}

\[
T_{\text{gen}} = O(\log n) + O(|s|) = O(\log n)
\]

Pour la génération d’une famille sur $P$ schèmes de longueur moyenne $\bar{s}$ :

\[
T_{\text{family}}(n,P)=O(\log n + P\cdot\bar{s})
\]

\subsection{Validation}

Validation par régénération exhaustive :

\begin{enumerate}[nosep]
\item Recherche de la racine dans l’ABR
\item Parcours des $P$ schèmes
\item Génération et comparaison
\end{enumerate}

\[
T_{\text{val}} = O(\log n + P)
\]

Cette méthode garantit la cohérence morphologique et évite les ambiguïtés d’une reconstruction inverse plus complexe.

\section{Complexité algorithmique}

Soient :
\begin{itemize}[nosep]
\item $n$ : nombre de racines
\item $P$ : nombre total de schèmes
\end{itemize}

\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{lcc}
\toprule
\textbf{Opération} & \textbf{Cas moyen} & \textbf{Pire cas} \\
\midrule
Recherche ABR            & $O(\log n)$         & $O(n)$ \\
Insertion ABR            & $O(\log n)$         & $O(n)$ \\
Suppression ABR          & $O(\log n)$         & $O(n)$ \\
Recherche hash           & $O(1)$              & $O(P)$ \\
Insertion hash           & $O(1)$              & $O(P)$ \\
Génération (1 mot)       & $O(\log n)$         & $O(n)$ \\
Validation (1 mot)       & $O(\log n + P)$     & $O(n + P)$ \\
Chargement racines       & $O(n\log n)$        & $O(n^2)$ \\
Chargement schèmes       & $O(P)$              & $O(P^2)$ \\
\bottomrule
\end{tabular}
\end{center}

\section{Choix algorithmiques}

\textbf{Arbre Binaire de Recherche:}  
Une structure linéaire (tableau ou liste) impliquerait une recherche en $O(n)$.  
L’ABR permet une recherche, insertion et suppression en $O(\log n)$ en moyenne, ce qui réduit significativement le coût des accès fréquents aux racines.  
Le choix d’un ABR simple a été privilégié pour limiter la complexité d’implémentation et le coût mémoire.

\textbf{Table de hachage:}  
Les schèmes sont accédés très fréquemment lors de la génération et surtout de la validation.  
Une table de hachage permet un accès en $O(1)$ en moyenne, plus performant qu’un ABR ($O(\log P)$).  
La taille $P$ en nombre premier plus grand que le nombre de schèmes réduit les collisions.  
Le chaînage a été choisi plutôt que l’adressage ouvert afin de simplifier la gestion des collisions et éviter les problèmes liés au redimensionnement.

\textbf{Validation exhaustive:}  
La validation repose sur la régénération complète des formes possibles à partir de tous les schèmes.  
Une reconstruction inverse serait plus complexe et ambiguë morphologiquement.  
La régénération garantit la cohérence avec l’algorithme de génération et assure l’unicité de la logique de dérivation.

\textbf{Normalisation:}  
La suppression des diacritiques et l’unification des variantes Unicode assurent des comparaisons robustes et évitent les incohérences dues aux différentes formes d’écriture arabe.

\section{Difficultés rencontrées}

\begin{itemize}[nosep]
\item Assurer une normalisation Unicode cohérente entre racines et schèmes.
\item Garantir la cohérence entre génération et validation afin d’éviter toute divergence logique.
\item Gérer efficacement les collisions dans la table de hachage tout en conservant une recherche rapide.
\item Maintenir une complexité maîtrisée tout en conservant une implémentation claire et modulaire.
\end{itemize}

\section{Point d’originalité}

Le moteur est exploité comme un dictionnaire morphologique : chaque schème peut être associé à une définition, et chaque dérivé validé peut être enrichi sémantiquement. Cette exploitation illustre l’application concrète des structures de données implémentées.
\section{Conclusion}

Le système combine ABR, table de hachage et listes chaînées de manière cohérente.  
Les performances sont dominées par $O(\log n)$ en moyenne pour les racines et $O(1)$ amorti pour les schèmes, ce qui rend le moteur efficace et extensible.

\end{document}