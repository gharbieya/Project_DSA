\documentclass[a4paper,11pt]{article}

% ============================================================
% Compile with: XeLaTeX  (required for Arabic Unicode + fontspec)
% ============================================================

% --- Fonts + languages (XeLaTeX) ---
\usepackage{fontspec}
\usepackage{polyglossia}
\setmainlanguage{french}
\setotherlanguage{arabic}

% Fonts (change Arabic font if you want)
\setmainfont{Latin Modern Roman}
\newfontfamily\arabicfont[Script=Arabic]{Traditional Arabic}
% Alternatives (if installed):
% \newfontfamily\arabicfont[Script=Arabic]{Amiri}
% \newfontfamily\arabicfont[Script=Arabic]{Arial}

% --- Mise en page / packages ---
\usepackage[margin=2.2cm]{geometry}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{amsmath,amssymb}
\usepackage{booktabs}
\usepackage{array}
\usepackage{hyperref}
\usepackage{bookmark} % helps hyperref outlines; optional but recommended
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{xcolor}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\small Rapport Technique -- Moteur Morphologique Arabe}
\fancyhead[R]{\small \thepage}
\renewcommand{\headrulewidth}{0.4pt}

\titleformat{\section}{\large\bfseries}{\thesection.}{0.5em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection.}{0.5em}{}
\setlength{\parskip}{0.4em}
\setlength{\parindent}{0em}

% -------------------------------------------------------------------
\begin{document}

\begin{center}
    {\LARGE \textbf{Rapport Technique}}\\[0.3cm]
    {\Large Moteur de Génération et de Validation\\Morphologique de la Langue Arabe}\\[0.5cm]
    {\normalsize Février 2026}
\end{center}

\hrule
\vspace{0.6cm}

% ===================================================================
\section{Introduction}

Ce projet implémente un \textbf{moteur morphologique} pour la langue arabe, capable de \textbf{générer} des mots dérivés à partir d'une racine trilitère et d'un schème (pattern), et de \textbf{valider} l'appartenance d'un mot à une racine donnée. L'architecture repose sur trois structures de données fondamentales~: un \textit{arbre binaire de recherche} (BST) pour les racines, une \textit{table de hachage} avec chaînage pour les schèmes, et des \textit{listes chaînées} pour les mots dérivés ainsi que pour la résolution de collisions.

% ===================================================================
\section{Structures de données utilisées}

\subsection{Arbre binaire de recherche (BST) -- Racines}

Les racines arabes trilitères (ex.\ \texttt{k-t-b}, \textarabic{كتب}) sont stockées dans un \textbf{arbre binaire de recherche} (\texttt{RootBST}). Chaque n\oe ud contient~:
\begin{itemize}[nosep]
    \item la racine sous forme compacte (3 lettres Unicode),
    \item un pointeur vers une liste chaînée de mots dérivés validés,
    \item des pointeurs \texttt{left} / \texttt{right}.
\end{itemize}

L'ordre est défini par la comparaison lexicographique Unicode native de Python. Les opérations proposées sont l'insertion, la recherche, la suppression (avec gestion du successeur in-order), le parcours in-order et le calcul de la hauteur.

\paragraph{Complexité:}
\begin{center}
\begin{tabular}{lcc}
\toprule
\textbf{Opération} & \textbf{Cas moyen} & \textbf{Pire cas} \\
\midrule
Insertion         & $O(\log n)$ & $O(n)$ \\
Recherche         & $O(\log n)$ & $O(n)$ \\
Suppression       & $O(\log n)$ & $O(n)$ \\
Parcours in-order & $O(n)$      & $O(n)$ \\
Hauteur           & $O(n)$      & $O(n)$ \\
\bottomrule
\end{tabular}
\end{center}

Le pire cas $O(n)$ survient lorsque l'arbre dégénère en liste (insertions triées). Le projet ne recourt pas à un arbre équilibré (AVL, rouge-noir)~; ce choix est volontaire afin de garder la structure simple tout en restant performant pour un nombre modéré de racines ($n < 10\,000$). En moyenne, les racines arabes, chargées depuis un fichier non trié, produisent un arbre raisonnablement équilibré, d'où une complexité pratique en $O(\log n)$.

\subsection{Table de hachage -- Schèmes morphologiques}

Les schèmes sont stockés dans une \textbf{table de hachage à chaînage} (\texttt{PatternHashTable}) de taille fixe $m = 37$ (nombre premier). Chaque cellule pointe vers une \texttt{PatternRuleChain}, liste chaînée de n\oe uds \texttt{PatternRuleNode} portant le schème normalisé et sa règle de dérivation.

\paragraph{Fonction de hachage.}
La fonction utilise un hachage polynomial~:
\[
h(k) = \left(\sum_{i=0}^{|k|-1} \text{ord}(k_i) \cdot 131^{i}\right) \bmod 37
\]
La base 131 (nombre premier) assure une bonne dispersion des caractères Unicode arabes. La taille 37 offre un compromis entre occupation mémoire et taux de collision pour un nombre de schèmes de l'ordre de quelques dizaines.

\paragraph{Complexité.}
\begin{center}
\begin{tabular}{lcc}
\toprule
\textbf{Opération} & \textbf{Cas moyen} & \textbf{Pire cas} \\
\midrule
Insertion   & $O(1)$     & $O(p)$ \\
Recherche   & $O(1)$     & $O(p)$ \\
Suppression & $O(1)$     & $O(p)$ \\
Itération   & $O(m + p)$ & $O(m + p)$ \\
\bottomrule
\end{tabular}
\end{center}
où $p$ est le nombre total de schèmes et $m = 37$ la capacité de la table. En pratique, avec $p \approx 30$ schèmes, le facteur de charge $\alpha = p/m \approx 0{,}81$ reste modéré et les chaînes sont courtes, garantissant un accès quasi-constant.

\subsection{Listes chaînées -- Mots dérivés et chaînage}

Les listes chaînées interviennent à deux niveaux~:
\begin{enumerate}[nosep]
    \item \textbf{DerivedWordList}~: rattachée à chaque n\oe ud racine du BST, elle stocke les mots dérivés validés avec un compteur de fréquence. L'insertion vérifie l'unicité ($O(d)$ pour $d$ dérivés existants) et incrémente le compteur en cas de doublon.
    \item \textbf{PatternRuleChain}~: utilisée pour le chaînage des collisions dans la table de hachage.
\end{enumerate}

\paragraph{Complexité.}
L'insertion avec vérification d'unicité et la recherche sont en $O(d)$ dans le pire cas, $d$ étant la longueur de la liste. La conversion en liste Python (\texttt{to\_list}, \texttt{to\_items}) est en $O(d)$.

% ===================================================================
\section{Algorithmes de génération et de validation}

\subsection{Génération morphologique}

L'algorithme de génération (\texttt{MorphologicalGenerator}) prend en entrée une racine et un schème, puis produit un mot dérivé. Le processus se décompose en~:

\begin{enumerate}[nosep]
    \item \textbf{Validation de la racine}~: recherche dans le BST -- $O(\log n)$ en moyenne.
    \item \textbf{Validation du schème}~: recherche dans la table de hachage -- $O(1)$ amorti.
    \item \textbf{Dérivation}~: la règle associée au schème est extraite. Les lettres-repères (\textarabic{ف}, \textarabic{ع}, \textarabic{ل}) sont remplacées par les 3 lettres de la racine. Le parcours du schème est en $O(|s|)$ où $|s|$ est la longueur du schème (typiquement 4--7 caractères).
    \item \textbf{Stockage}~: le mot dérivé est ajouté à la \texttt{DerivedWordList} du n\oe ud racine.
\end{enumerate}

\paragraph{Complexité totale d'une génération unitaire~:}
\[
T_{\text{gen}}(n, p) = O(\log n) + O(1) + O(|s|) = O(\log n)
\]
La génération d'une famille complète (tous les schèmes pour une racine, \texttt{generate\_family}) itère sur les $p$ schèmes~:
\[
T_{\text{family}}(n, p) = O(\log n) + O\!\left(\sum_{i=1}^{p}(1 + |s_i|)\right) = O(\log n + p \cdot \bar{s})
\]
où $\bar{s}$ est la longueur moyenne d'un schème.

\subsection{Validation morphologique}

L'algorithme de validation (\texttt{MorphologicalValidator}) détermine si un mot donné peut être dérivé d'une racine. La stratégie adoptée est une \textbf{validation par ré-génération exhaustive}~:

\begin{enumerate}[nosep]
    \item \textbf{Recherche de la racine} dans le BST -- $O(\log n)$.
    \item \textbf{Itération} sur tous les schèmes de la table de hachage.
    \item Pour chaque schème, \textbf{génération} du mot dérivé correspondant via le générateur.
    \item \textbf{Comparaison} du mot généré (normalisé) avec le mot saisi (normalisé).
    \item Si une correspondance est trouvée~: résultat \texttt{OUI} + schème identifié. Sinon~: \texttt{NON}.
\end{enumerate}

\paragraph{Complexité totale d'une validation~:}
\[
T_{\text{val}}(n, p) = O(\log n) + O(p \cdot \bar{s}) = O(\log n + p)
\]

% ===================================================================
\section{Choix et justification des algorithmes}

\begin{itemize}[leftmargin=*]
    \item \textbf{BST non équilibré pour les racines}~: la morphologie arabe comporte environ 6\,000 à 10\,000 racines trilitères. Un BST non équilibré offre une implémentation simple et reste efficace si les données ne sont pas insérées dans un ordre parfaitement trié, ce qui est le cas en pratique.
    \item \textbf{Table de hachage à taille fixe pour les schèmes}~: le nombre de schèmes morphologiques est restreint (quelques dizaines).
    \item \textbf{Validation par ré-génération}~: stratégie viable car $p$ est petit (constant en pratique).
    \item \textbf{Listes chaînées pour les dérivés}~: le nombre de dérivés par racine est faible.
\end{itemize}

% ===================================================================
\section{Analyse globale de la complexité}

\subsection{Complexité spatiale}

\begin{itemize}[nosep]
    \item \textbf{BST}~: $O(n)$.
    \item \textbf{Table de hachage}~: $O(m + p)$, avec $m = 37$.
    \item \textbf{Listes dérivées}~: $O(D)$ au total.
    \item \textbf{Espace total}~: $O(n + p + D)$.
\end{itemize}

\subsection{Complexité temporelle -- Récapitulatif}

\begin{center}
\begin{tabular}{l c c}
\toprule
\textbf{Opération} & \textbf{Cas moyen} & \textbf{Pire cas} \\
\midrule
Insertion d'une racine         & $O(\log n)$     & $O(n)$ \\
Recherche d'une racine         & $O(\log n)$     & $O(n)$ \\
Suppression d'une racine       & $O(\log n)$     & $O(n)$ \\
Insertion d'un schème          & $O(1)$          & $O(p)$ \\
Recherche d'un schème          & $O(1)$          & $O(p)$ \\
Génération unitaire            & $O(\log n)$     & $O(n)$ \\
Génération familiale           & $O(\log n + p)$ & $O(n + p)$ \\
Validation d'un mot            & $O(\log n + p)$ & $O(n + p)$ \\
Chargement racines fichier     & $O(n \log n)$   & $O(n^2)$ \\
Chargement schèmes fichier     & $O(p)$          & $O(p^2/m)$ \\
\bottomrule
\end{tabular}
\end{center}

% ===================================================================
\section{Principales difficultés rencontrées}

\begin{enumerate}[leftmargin=*]
    \item \textbf{Normalisation Unicode de l'arabe}~: gestion des variantes et diacritiques.
    \item \textbf{Correspondance racine-schème}~: mapping \textarabic{ف-ع-ل}.
    \item \textbf{Dégénérescence du BST}~: possible avec un fichier trié.
    \item \textbf{Validation sans analyseur morphologique}~: ré-génération exhaustive.
\end{enumerate}

% ===================================================================
\section{Conclusion}

Le moteur morphologique proposé combine trois structures de données classiques de manière cohérente. L'analyse de complexité montre que le système est efficace pour un usage pratique~: $O(\log n)$ pour les opérations courantes sur les racines et $O(1)$ amorti pour les schèmes.

\end{document}