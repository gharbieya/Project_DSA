\documentclass[11pt,a4paper]{article}

% Compile with XeLaTeX

\usepackage{fontspec}
\usepackage{polyglossia}
\setmainlanguage{french}
\setotherlanguage{arabic}

\setmainfont{Latin Modern Roman}
\newfontfamily\arabicfont[Script=Arabic]{Traditional Arabic}

\usepackage[margin=2.3cm]{geometry}
\usepackage{setspace}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{enumitem}
\usepackage{titlesec}
\usepackage{fancyhdr}

\setstretch{1.1}
\setlength{\parindent}{0pt}
\setlength{\parskip}{0.4em}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[R]{\thepage}
\renewcommand{\headrulewidth}{0.2pt}

\titleformat{\section}{\large\bfseries}{\thesection.}{0.5em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection.}{0.5em}{}

\begin{document}

\begin{center}
{\Large \textbf{Rapport Technique}}\\[0.2cm]
{\normalsize Moteur de Génération et Validation Morphologique Arabe}\\[0.3cm]
{\small Eya Gharbi -- Zaghouani Ayoub}\\
{\small Classe 1ING4}
\end{center}

\section{Présentation générale}

Ce projet implémente un moteur de dérivation morphologique arabe capable de générer des formes dérivées à partir d’un radical trilitère et d’un schème, et de valider si un mot dérivé appartient à un radical donné.

\section{Chargement des données}

Au démarrage :
\begin{itemize}[nosep]
\item \texttt{roots.txt} charge les racines dans un ABR.
\item \texttt{patterns.txt} charge les schèmes dans une table de hachage.
\end{itemize}

\section{Structures de données}

\subsection{Arbre Binaire de Recherche (ABR)}

Les racines trilittérales (ex : \textarabic{ك-ت-ب}) sont stockées sous forme compacte (\textarabic{كتب}).  
La comparaison repose sur l’ordre Unicode.

Chaque nœud contient :
\begin{itemize}[nosep]
\item la racine compacte.
\item une liste chaînée de dérivés.
\item deux pointeurs (gauche/droite).
\end{itemize}

\textbf{Normalisation :}
suppression des diacritiques, unification des variantes d’alef, vérification stricte du format.

\textbf{Insertion :}
Descente récursive selon l’ordre lexicographique. Doublons refusés.

\textbf{Suppression :}
La suppression suit les trois cas classiques : feuille, un enfant, deux enfants avec remplacement par le successeur.

\subsection{Liste chaînée}

Chaque racine possède une liste de mots dérivés (mot + fréquence).  
Elle permet un stockage léger et évite les recalculs.

\subsection{Table de hachage}

Les schèmes sont stockés dans une table de hachage de taille fixe $m=37$ (nombre premier).  

Fonction de hachage polynomiale :

\[
h(k)=\left(\sum_{i=0}^{|k|-1} \operatorname{ord}(k_i)\cdot131^i\right)\bmod 37
\]

\textbf{Type d’entrée.} 
Les schèmes sont validés :
\begin{itemize}
    \item présence des lettres \textarabic{ف ع ل}.
    \item lettres arabes uniquement.
    \item conservation de la shadda (si présente).
\end{itemize}

\textbf{Normalisation:}
Chaque schème est normalisé (diacritiques supprimés sauf shadda, variantes d’alef unifiées).  
Les schèmes doivent contenir \textarabic{ف ع ل} et respecter une longueur minimale.

\textbf{Règle de dérivation:} Elle est identique au schème normalisé (\texttt{rule = pattern}).  
La dérivation consiste à substituer \textarabic{ف ع ل} par les lettres de la racine.

\textbf{Chaînage:} Chaque case de la table pointe vers une \textbf{liste chaînée} de schèmes.  
Si deux schèmes ont le même hash, ils sont ajoutés à la liste du même bucket.  
La recherche parcourt cette liste jusqu’à trouver la clé exacte.


\section{Algorithmes}

\subsection{Génération}

\begin{enumerate}[nosep]
\item Normalisation de la racine donnée
\item Recherche dans l’ABR
\item Recherche du schème dans la table de hachage
\item Application de la règle de dérivation
\item Stockage dans la liste chaînée de la racine
\end{enumerate}

Complexité :

\[
T_{\text{gen}} = O(\log n) + O(|s|) = O(\log n)
\]

Pour la génération d'une famille sur les $p$ schèmes de longueur moyenne $\bar{s}$ :
\[
T_{\text{family}}(n, p) = O(\log n) + O\!\left(\sum_{i=1}^{p}(1 + \lvert s_i\rvert)\right) = O(\log n + p \cdot \bar{s})
\]

\subsection{Validation}

Validation par régénération exhaustive :

\begin{enumerate}[nosep]
\item Recherche racine dans l’ABR
\item Parcours des $m$ schèmes
\item Génération + comparaison
\end{enumerate}

\[
T_{\text{val}} = O(\log n + P)
\]

\section{Complexité Algorithmiquekjernvkjnqerjgn}

Soient :
\begin{itemize}[nosep]
\item $n$ : nombre de racines
\item $P$ : nombre total de schèmes
\end{itemize}

\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{lcc}
\toprule
\textbf{Opération} & \textbf{Cas moyen} & \textbf{Pire cas} \\
\midrule
Recherche ABR            & $O(\log n)$         & $O(n)$ \\
Insertion ABR            & $O(\log n)$         & $O(n)$ \\
Suppression ABR          & $O(\log n)$         & $O(n)$ \\
Recherche hash           & $O(1)$              & $O(P)$ \\
Insertion hash           & $O(1)$              & $O(P)$ \\
Génération (1 mot)       & $O(\log n)$         & $O(n)$ \\
Validation (1 mot)       & $O(\log n + P)$     & $O(n + P)$ \\
Chargement racines       & $O(n\log n)$         & $O(n^2)$ \\
Chargement schèmes       & $O(P)$               & $O(P^2)$ \\
\bottomrule
\end{tabular}
\end{center}

\section{Choix algorithmiques}

\textbf{Arbre Binaire de Recherche (ABR):}  
Les racines sont stockées dans un ABR pour permettre une recherche efficace avec un faible coût mémoire.  
En moyenne, les opérations de recherche et d’insertion sont en $O(\log n)$.

\textbf{Table de hachage:}  
Une table de hachage est utilisée pour assurer un accès rapide aux schèmes, avec un coût moyen en $O(1)$.

\textbf{Validation exhaustive:}  
La validation consiste à générer les formes à partir de tous les schèmes et à comparer les résultats.  
Cette méthode garantit la cohérence morphologique.

\textbf{Normalisation:}  
La suppression des diacritiques et l’unification des lettres assurent des comparaisons fiables et évitent les ambiguïtés Unicode.

\section{Difficultés rencontrées}

\begin{itemize}[nosep]
\item Normalisation cohérente entre racines et schèmes.
\item Gestion des collisions dans la table de hachage.
\item Contrôle des duplicatas dans ABR et hash.
\end{itemize}

\section{Point d’originalité}

Le système est exploité comme un \textbf{dictionnaire morphologique} : chaque schème est associé à une définition, et chaque dérivé validé peut être affiché avec son sens linguistique. Cette exploitation donne une valeur appliquée aux structures de données.
Cette exploitation démontre l’application concrète des structures algorithmiques développées.

\section{Conclusion}

Le système combine ABR, table de hachage et listes chaînées de manière cohérente.  
Les performances sont dominées par $O(\log n)$ en moyenne pour les racines et $O(1)$ amorti pour les schèmes, ce qui rend le moteur efficace et extensible.

\end{document}